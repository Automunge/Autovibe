# Autovibe
Running some experiments on codespace configurations for cloud based vibe coding dev environment. Limiting future citations towards human authored material. Targeting to run on ipad pro with monitor / mouse / keyboard, github codespaces with VSCode or jupyter in browser. Future extensions may include additional modules like database access, agentic LLM aggregations, optimizer components, SSH connections, TBD. Basically was looking for a new building project and while I hone in on what that will be wanted to start laying foundations. (I find the iOS operating system tends to be more stable than other resources so will try to work around whatever limitations come up using cloud resources where possible and leveraging reputable docker containers and libraries with a "minimalist" import bias.)

Some early experiments indicate that the use of VSCode in iOS browsers is not always a seemless experience. Even working with Apple branded products like the iPad pro with M4, Magic Keyboard, and Mouse the VSCode editor appears to intermittently drop keyboard access, particularly when running a jupyter notebook through VSCode. These appear to often be triggered by switching browser tabs. 

Fortunatgely the jupyterlabs convention for accessing jupyter notebooks appears to be beter supported on iOS web browsers. Not yet certain which iOS browser is best to default to, it appears that Safari may be suitable for jupyterlabs but Edge possibly has better stability for VSCode in browser. I think a reasonable workflow might be to keep both VSCode and Jupyter running in seperate tabs and rely on jupyter for notebook editting and VSCode for codespace management. Probably good practice to frequently save noteboks during editting or activating some kind of autosave feature.

After some experimentation and with support of LLM I settled on a devcontainer setup of seperate files for devcontainer.json and Dockerfile in the devcontainer folder, where my understanding is that when Github initiates to build an active codespace it starts by inspecting the devcontainer.json, which then routes to the Dockerfile where in this setup is listed a base docker/devcontainer image, currently sourced from a repository hosted by Microsoft, and after loading the base image (which comes prepopulated with python in a Ubuntu system). The Dockerfile then installs a couple of additional OS related modules (which I haven't gone through in detail yet) and then pip installs a few python packages which for this setup will serve as bulk of use for coding. Initially this setup will focus on python workflows but this kind of docker container is equally capable of initiallizing alternative programming environments (like C++, Rust, etc) since it is basically an encapsulated Unix system hosted on github servers. After completing the Dockerfile setups, the devcontainer.JSON as configurated here includes a few additional setup operations including initializing any API keys stored seperately in the github portal which has a codespaces option for such (which is helpful since if this docker container is adapted to other users or usecases it becomes possible to initialize a speerate API key for each user without needing to update the devcontainer). The devcontainer.json also populates a few VSCode extensions (which I haven't yet gone through in detail) and then intializes the '8888' port used for accessing jupyter in a seperate tab (8888 is a common plug value for this use).

Importantly, by initializing with a base devcontainer in a repoutable hosted repository (currently in a venue managed by Microsoft), we should be able to offload any Unix system management to their oversite which frees us to mainly focus on those libraries that we are interested in for vibe coding.

I also expect that the convention of using a Dockerfile for base OS and pip install and the the devcontainer.json for VSCode and additional supplemental modules should make it easier to manage tweaking this for different covnetions, since the two can be made fairly modular.

Note that the initialization of the Codespace appears to be somewhat difficult to troubleshoot when  the are formatting issues in the devcontainer components. One should pay special attention to things like basic JSON formatting.

Part of the appeal of this form of dev environment is that when tools like VSCode are run locally on PC systems like Windows or MacOS, they are exposed to whatever security channels may be in play for user managed systems. iOS has a reputation as being a more secure OS, particularly since the app store has comprehensive oversight by Apple for distributed sofrtware, and although not foolproof I think it is reasonable that in aggregate most iOS systems, when kept up to date for software patches, can be expected as more predictable and secure than other PC systems. Further, the cost of staying up to date on configurations of locally managed hardware gets harder and harder given so much rapid iterations in CPU/GPU conventions. A user can invest heavily in a desktop setup only to find it obsolete in a few months. The iPads are both secure and expected as more durable since Apple has shown talent at a reliable and predictable upgrade cycle. Whether the modern iPad pro's have sufficient things like RAM for browser based editting is a little harder to quantify, lately the browsers have gotten reputation as most memory hogging apps of these systems. I will keep an eye out for future bottlenecks as may present themselves.

The github codespaces for hosted cloud sessions has their own limitations. It appears that for the most part, although github allows you to select between different CPU/RAM configurations, the availabiltiy of things like dedicated GPU hardware is not an available feature. So far for me this is an acceptible tradeoff considering the affordability of the system (paritcularly with a github pro account which includes free hours) and with the expectation that I will primarily rely on API calls for sourcing cloud compute for operations that require more significant hardware.

Is a little early to finalize these components as am still in the proof of cxoncept stage, but after some thought around security best practices came to following conclusions:
* the monitoring of this repository for known vulnerabilities I settled on an external resource from the vendor Snyk, which I had some experience with from another library. Although they have some forms of github integration / VSCode extensions available, for now I am mainly relying on their weekly reports from monitoring the github repo. It appears there is some time lag from intialization to seeing first report, I saw that initializing a requirements.txt file in the repo can help Snyk to recognize this as a project for monitoring so created one, the intent as that as Snyk's weekly emails come through if there are any reported vulnerabilities from external library imports I will track them through the github issues field in some fashion. My understanding is that Snyk is capable of reporting known vulnerabilities of imports to a library. Eventually we may extend to consider actively running Snyk each time a user intializes a codespace to validate in real time the imports are approrpiate, I haven't experimented with this yet, am not sure how much time lag that would create towards initalizing a mnew codespace. (I suspect that our convention of relying on a Devcontainer file in conjunction with a seperate devcontainer.json file could lead to a convention where we pre-initialize the runtimes with Dockerfile through github and then allow any user deviaitons to the initalizaiton be populated in the devcontainer.json file, which could have potential to speed these kind of things up.)
* the initializing of API keys to the repo via a devcontainer.json entry for "containerEnv" is not a perfect solution, my understanding is that this is accessing the API key stored in Github Secrets and populating as an environmental variable to the codespace's operating system which can then be acessed in processes by the os library. As this system gets closer to deployment I intend to look closer into integrating something resembling the Hashicorp Vault product which allows you to better control the scoping of API keys to processes running in the operating system, which can mitigate an obvious security channel. Part of my hesitation for immediate integration is that Vault is a paid product so is a little more complicated than just importing a library, you in parallel need to have user accounts and etc which would make this resource a little less modular.
* Speaking of security channels, another broader one that I think the python ecosystem as a whole could beenfit from is flagging user imports prior to install with known vulnerabilities, which resources like Snyk are capable of. Although this is currently outside the scope of this project, ideally if this type of product were to get users outside of the experienced developer community we would want some way to "handhold" users to avoid obvious channels for security, such as pip installs of libraries with typo spellings or otherwise sketchy systems. Even if we don't bar imports of flagged libraries explicitly at least a flag to user attention could shift any claims of liability from LLM to user for cases where model recomends installing a wrong library. After all an API key in the wrong hands can lead to real financial repurcusions.
* Right now the set of VS Code imports are pretty small and is another aspect I will need to dig into deeper, I expect they also have various solutions to benefit security, however as it appears we will in parallel be relying on a jupyterlabs notebook interface for purposes of in browser coding on ipad, we are also assuming users are going to operate in the more minimal interface / plugin libraries of the julpyterlabs envirnoment. In some sense the jupyterlabs UI is superior to VSCode due to simplicity from a much smaller scope, but in other cases VSCodes' extensive library of potential modules may have more options to accomodate different edge cases, at least that is my impression, so there are tradeoffs.

With regards to the best browser experience for the coding environment, I had looked deeper into the options and it appears that as iOS follows convention of consistent kernel for browser between apps ("WebKit"), defaulting to Safari appears to be a clean solution as it has the least amount of clutter layered on top. And then for the coding experience explicitly, it appears that some web pages in Safari (like the VSCode interface) have a neat option to exit from the browser into a standalone and more app-like experience which they call a PWA (Progressive Web App). Without digging into the specific of how they are implemented, it appears that the intialization of a PWA for a supported website is as simple as going into Safari, using the share button at top of screen, and selecting "Adde to Home Screen". The beenfit of the PWA convention appear to be that even though the website is still given retained access to web, it is granted an interface that omits the Safari overhead, which means that all of those issues that may arrise from eg switching between tabs in an active browser session are circuvented. This looks like it would be a great default for Codespace access on iOS, particularly as it allows us to set aside any complexity that would arrise from trying to configure SSH keys in some fashion for more traditional terminal based connections. The expectation is that this PWA approach should mitigate a lot of those interface issues like keyboard and mouse retention for the VSCode browser environment on iOS, and then as long as a codespace remains active one can simply access the environment from an app link on the ipad home screen as opposed to navigating through Safari. Very clean solution.

Having established such app interface intent, a next point of interest that I would like this library to integrate will be associated with how we can make our coding journey more seamless for direct interactions with the language model, which will naturally necessitate the model being aware of and having access to the contents of the codespace. So the lazy approach would obviously be to just default to using VSCode’s GitHub copilot plugin, but from an optionality standpoint I think that would sacrifice potential to take advantage of future options as various tools mature. Integrating tools that move a codebase into a chunking and vector database are likewise going to be overly reliant on vendor specific conventions. From a standpoint of modularity and making a clean interface boundary that can be adapted to various configurations, to me the most obvious approach, at least from a starting point standpoint, would be to create a convention for loading a repo into the LLM tool at codespace initialization and then whenever we want to load additional context into the model, make it reliant on a Git commit to the repo serving as basis for the codespaces. Thus as models get more capable of expanding context window or otherwise memory integration of some kind we can ride that trend. This approach also has the advantage of built in version control for repeatability towards basis of model interactions and traceability. 

An additional folder was added to this template to support these operatioms as LLM_context. It includes a load.py file for defining a process to load comtext of a repo into the vibe codong LLM model with repo git commits, a loadconfig.json file containing settings and options for such operation, and a summaries.txt file to serve as a set of natural language summaries corresponding to each file in the repo. 

Speaking of natural language, another feature of the Autovibe I have considered is associated with how to incorporate spoken language input into a user coding session. For purposes of the intended workflow (leveraging Safari browser to use VSCode in a Github Codespaces hosted container), I decided the most future-proof way to integrate such form of input would be to leverage Apple developer tooling to the full extent possible. Based on current resources published by Apple, it appears the best way to do that is by way of their Shortcuts app, which I found the easiest way was possibly to create a shortcut to "Dictate Text", and then to "Copy Dictasted Text to Clipboard". Due to Apple's sandboxing approach for security of their natural langugae input, the dictation from spoken word as channeled to a GUI won't be seemless, but it will be close as once the dictation feature is accessed we can then simply apply a more traditional paste operation to place the input directly into the coding terminal. Then in order to access that Siri shortcut we can create a Vocal Shortcut in the Accessibility menu to iniate by way of saying Siri and our specified Keyword (for now am intending to use something like "Siri Autovibe" to accept dictation input for simplicity).
